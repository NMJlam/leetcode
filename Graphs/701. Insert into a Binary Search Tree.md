## Trick
> The trick here is that after iterating, the insertion position is at a leaf node

```python
def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:

	def insert(root, val):
	
		if not root or not root.val:
			return TreeNode(val)
		
		if not root.left and val < root.val:
			root.left = TreeNode(val)
		
		if not root.right and val > root.val:
			root.right = TreeNode(val)
		
		if val < root.val:
			insert(root.left, val)
		
		if val > root.val:
			insert(root.right, val)
		
		return root

	return insert(root, val
```
## Approach
1) Check if the node is empty 
2) Traverse the nodes until we reach an empty node 
3) Insert at that node 

## Improvements
- Make the solution more idiomatic 
- Crystallise your solution before you write it down, so that you can create a clear solution 

> This  is a more idiomatic approach:
```python
def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:

	def insert(root, val):
		if not root:
			return TreeNode(val)
		
		if val < root.val:
			root.left = insert(root.left, val)
		
		if val > root.val:
			root.right = insert(root.right, val)
		
		return root
	
	return insert(root, val)
```
- Because we just reassign the children to the entire path that we are traversing.
- Also, it is easier to read 