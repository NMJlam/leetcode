## Approach 
```python
class MyHashSet:

	def __init__(self):
		self.elems = []

	def add(self, key: int) -> None:
		n = len(self.elems) - 1
		if key > n:
			self.elems.extend([0 for _ in range(key - n + 1)])
		self.elems[key] = 1

	def remove(self, key: int) -> None:
		n = len(self.elems) - 1
		if key <= n:
			self.elems[key] = 0
		
	def contains(self, key: int) -> bool:
		n = len(self.elems) - 1
		if n >= key:
			return self.elems[key] == 1
		return False
```

## Optimal Solutions 
##### Linked List
```python 
class MyHashSet:

	def __init__(self):
		self.buckets = 10 ** 4
		# create 1000 buckets
		self.elems = [Node(float("inf")) for _ in range(self.buckets)]
		
	def add(self, key: int) -> None:
		hashKey = key % self.buckets
		currNode = self.elems[hashKey]
		
		while currNode.next is not None:
			# did not verify to not add duplicates
			if currNode.next.val == key:
				return
			currNode = currNode.next
		currNode.addNext(key)
	
	  
	
	def remove(self, key: int) -> None:
		hashKey = key % self.buckets
		currNode = self.elems[hashKey]
		
		while currNode.next:
			if currNode.next.val == key:
				nextNextNode = currNode.next.next
				currNode.next = nextNextNode
				# should exit if we removed instead of iterating
				return
		currNode = currNode.next
	
	def contains(self, key: int) -> bool:
		hashKey = key % self.buckets
		currNode = self.elems[hashKey]
		
		while currNode.next:
			'''
			you need currNode.next.val because of the head node
			if you checked only currNode.val then you'd miss the last nodes value
			'''
			if currNode.next.val == key:
				return True
			currNode = currNode.next
			return False
	
class Node:
	def __init__(self, val) -> None:
		self.val = val
		self.next = None
	def addNext(self, nextVal) -> None:
		# Create a node
		node = Node(nextVal)
		self.next = node
```
This is more optimal because it bounds the search length to a fixed size rather than extend to the bounds of $10^6$

###### Main mistakes for this implementation:
- Did not consider the edge cases for each function 
- Should check termination conditions more carefully 
###### Next time 
- Should focus on figuring out the edge cases and explaining the steps of each careful so that I can scrutinise the logic more carefully

##### Binary Search Tree
> Requires:
> [[700. Search in a Binary Search Tree]]
> [[701. Insert into a Binary Search Tree]]
> [[450. Delete Node in a BST]]

Instead of a linked list we use a binary search tree. 
- Collectively: $O(height\ of\ binary\ tree)$
- Best case: $O(log(n))$ 
- Worst case: $O(N)$ - At worst the same as the linked list approach
