## Approach 

### 1) Question explanation:
The question is asking me to reverse an integer:
- Removing the leading zeros when reversed 
- Maintaining the signed/unsigned nature of the integer 
>But we need to ensure that the integer maintains the 32-bit integer bound

## 2) Test cases:
```python 
num = -123
return -321
```
> Maintains the signed integers

```python
num = 120
return = 21 
```
> Removes the leading zeros

```python
num = 01111111111 (whatever the upper bound of 32 bit integers are)
return 0
```
> Maintains the bounds of the 32-bit intgers

## 3) Describe the algorithm

**Naive Solution**
1) Convert the number to a string 
2) Check if the number is signed or not
3) Remove the zeros at the back 
4) Convert the string into an integer 
5) Check the upper/lower bound of the integer 
6) Multiply if signed or not
> The complexity is $O(N)$
```python
class Solution:
	def reverse(self, x: int) -> int:
		# Convert the number to a string
		xString = str(x)
		
		# Check if signed or not
		signed = True if xString[0] == '-' else False
		
		# Remove the sign if there is one
		xString = xString[1:] if signed else xString
		
		# Remove the zeros at the back
		noZeros = xString.rstrip()
		
		# convert the string to an integer and reverse
		num = int(noZeros[::-1])
		
		# Check if signed or not and check respective bounds
		if signed:
			return 0 if num >= (2 **31) else num * -1
		else:
			return 0 if num >= (2 ** 31) - 1 else num
```

==There is a better solution - with bit-manipulation i think... ==

