## Approach 

### 1) Question explanation:
The question is asking me to reverse an integer:
- Removing the leading zeros when reversed 
- Maintaining the signed/unsigned nature of the integer 
>But we need to ensure that the integer maintains the 32-bit integer bound

## 2) Test cases:
```python 
num = -123
return -321
```
> Maintains the signed integers

```python
num = 120
return = 21 
```
> Removes the leading zeros

```python
num = 01111111111 (whatever the upper bound of 32 bit integers are)
return 0
```
> Maintains the bounds of the 32-bit intgers

## 3) Describe the algorithm

**Naive Solution**
1) Convert the number to a string 
2) Check if the number is signed or not
3) Remove the zeros at the back 
4) Convert the string into an integer 
5) Check the upper/lower bound of the integer 
6) Multiply if signed or not
> The complexity is $O(N)$
```python
class Solution:
	def reverse(self, x: int) -> int:
		# Convert the number to a string
		xString = str(x)
		
		# Check if signed or not
		signed = True if xString[0] == '-' else False
		
		# Remove the sign if there is one
		xString = xString[1:] if signed else xString
		
		# Remove the zeros at the back
		noZeros = xString.rstrip()
		
		# convert the string to an integer and reverse
		num = int(noZeros[::-1])
		
		# Check if signed or not and check respective bounds
		if signed:
			return 0 if num >= (2 **31) else num * -1
		else:
			return 0 if num >= (2 ** 31) - 1 else num
```

==There is a better solution - with bit-manipulation i think... ==

**Optimal Solution**
1) Compare to ensure that `bound[::-1] < x[::-1]`
2) Compare to ensure that if `bound[::-1] == x[::-1]` then we need to also compare `x[-1] < bound[-1]`
> The thing that is particularly interesting is the use of `%` and `//` to iterate through integers 

Time: $O(1)$
> The complexity is not $O(N)$ because the number of iterations in bounded by the number of digits of a 32-bit integer

Space: $O(1)$

```python
class Solution:
	def reverse(self, x: int) -> int:
	
		lower, upper = -2 ** 31, 2 ** 31 - 1
		
		res = 0
		
		while x:
			# get the current digit
			currDigit = int(math.fmod(x, 10))
			
			# move the iteration forward
			x = int(x / 10)
			
			# compare the bounds[::-1] with x[::-1]
			if (res < lower // 10 or res > upper // 10):
				return 0
			
			# case where the bounds[::-1] == x[::-1], then compare the last digits
			if ((res == lower // 10 and currDigit < lower % 10)
				or (res == upper // 10 and currDigit > upper % 10)):
				return 0
			
			# stack the digits
			res = (res * 10) + currDigit
	
		return res
```


