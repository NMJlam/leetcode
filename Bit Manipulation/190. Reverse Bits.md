### Explanation
1) Receive a number `n`
2) Reverse the binary of the number `n`
3) Once reversed, convert the number back into base 10

### Edge Cases & Clarifications

Constraints:
- The integer is bound by $0 \leq n \leq 2^{31} - 2$ 
> This ensures that we only have positive numbers

- The number is even
> This together means that we miss the 0th place

Edge cases:
```python
bin(n) = 1111111111111 || 000000000000
# Do we just return the same thing? -> yes
```

### Pseudo Code / High level approach
1) Convert the number to binary
2) Treat the binary as a stack, with the end of the binary representation as the top of the stack
3) Pop it and then push it onto a new result until the binary representation has no more digits

**Naive Approach**
Space: $O(Number\ of\ Digits) = O(1)$
Time: $O(Number\ of\ Digits) = O(1)$ 
> This involves turning the binary into a list -> still $O(1)$ because we have the number of digits bounded by 32 bits


**Optimal**
Space: $O(Number\ of\ Digits) = O(1)$
Time: $O(Number\ of\ Digits) = O(1)$ 
> This involves just using the integers as a stack with the modulo and integer division

```python
class Solution:
	def reverseBits(self, n: int) -> int:
		# pad to make it a 32b integer
		nBin = f"{n:032b}"
		res = 0
		for digit in reversed(nBin):
			res = (res * 10) + int(digit)
		return int(str(res), 2)
```

### ==Corrected==

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for i in range(32):
			# shift to the rightmost bit
            bit = (n >> i) & 1
			# shift to the leftmost bit and add
            res += (bit << (31 - i))
        return res
```
> The thinking is the same as the previous but we are doing with bitwise operations
> This is more efficient because we are dealing with the bits themselves instead of converting binary into strings

Space: $O(Number\ of\ Digits) = O(1)$
Time: $O(Number\ of\ Digits) = O(1)$ 